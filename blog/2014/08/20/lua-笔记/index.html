<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>lua 笔记 - Pengcheng的点点滴滴</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pengcheng Li" />
    <meta name="description" content="" />
    <meta name="keywords" content="lua" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pengcheng的点点滴滴</a></h1>
        <p>路漫漫</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/ricardolee">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="blog.lpch.me">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>lua 笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Part I: The Language</a>
<ul>
<li><a href="#sec-1-1">开始</a>
<ul>
<li><a href="#sec-1-1-1">Chunks</a></li>
<li><a href="#sec-1-1-2">一些语言约定</a></li>
<li><a href="#sec-1-1-3">全局变量</a></li>
<li><a href="#sec-1-1-4">独立解释器</a></li>
</ul>
</li>
<li><a href="#sec-1-2">类型和值</a>
<ul>
<li><a href="#sec-1-2-1">Nil</a></li>
<li><a href="#sec-1-2-2">Booleans</a></li>
<li><a href="#sec-1-2-3">Numbers</a></li>
<li><a href="#sec-1-2-4">Strings</a></li>
<li><a href="#sec-1-2-5">Tables</a></li>
<li><a href="#sec-1-2-6">Functions</a></li>
<li><a href="#sec-1-2-7">Userdata 和 Threads</a></li>
</ul>
</li>
<li><a href="#sec-1-3">表达式</a>
<ul>
<li><a href="#sec-1-3-1">算数运算</a></li>
<li><a href="#sec-1-3-2">关系运算</a></li>
<li><a href="#sec-1-3-3">逻辑运算</a></li>
<li><a href="#sec-1-3-4">连接</a></li>
<li><a href="#sec-1-3-5">取长度</a></li>
<li><a href="#sec-1-3-6">优先级</a></li>
<li><a href="#sec-1-3-7">构造表</a></li>
</ul>
</li>
<li><a href="#sec-1-4">程序语句</a>
<ul>
<li><a href="#sec-1-4-1">赋值</a></li>
<li><a href="#sec-1-4-2">本地变量和块</a></li>
<li><a href="#sec-1-4-3">流程控制语句</a></li>
<li><a href="#sec-1-4-4">break, return, and goto</a></li>
</ul>
</li>
<li><a href="#sec-1-5">函数</a>
<ul>
<li><a href="#sec-1-5-1">多返回值</a></li>
<li><a href="#sec-1-5-2">多样的函数</a></li>
<li><a href="#sec-1-5-3">命名参数</a></li>
</ul>
</li>
<li><a href="#sec-1-6">更多的函数内容</a>
<ul>
<li><a href="#sec-1-6-1">闭包</a></li>
<li><a href="#sec-1-6-2">非全局函数</a></li>
<li><a href="#sec-1-6-3">恰当的尾调用</a></li>
</ul>
</li>
<li><a href="#sec-1-7">迭代器和通用for</a>
<ul>
<li><a href="#sec-1-7-1">迭代器和闭包</a></li>
<li><a href="#sec-1-7-2">通用for的语意</a></li>
<li><a href="#sec-1-7-3">无状态迭代器</a></li>
<li><a href="#sec-1-7-4">综合状态的迭代器</a></li>
<li><a href="#sec-1-7-5">真迭代器</a></li>
</ul>
</li>
<li><a href="#sec-1-8">编译执行和错误处理</a>
<ul>
<li><a href="#sec-1-8-1">编译</a></li>
<li><a href="#sec-1-8-2">预编译代码</a></li>
<li><a href="#sec-1-8-3">C代码</a></li>
<li><a href="#sec-1-8-4">错误处理</a></li>
<li><a href="#sec-1-8-5">错误处理和异常</a></li>
<li><a href="#sec-1-8-6">错误调用栈信息</a></li>
</ul>
</li>
<li><a href="#sec-1-9">协同程序</a>
<ul>
<li><a href="#sec-1-9-1">协同程序基础</a></li>
<li><a href="#sec-1-9-2">管道和过滤器</a></li>
<li><a href="#sec-1-9-3">把协同程序作为迭代器</a></li>
<li><a href="#sec-1-9-4">非抢占式多线程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Part II: Table and Objects</a>
<ul>
<li><a href="#sec-2-1">数据结构</a>
<ul>
<li><a href="#sec-2-1-1">数组</a></li>
<li><a href="#sec-2-1-2">矩阵多维数组</a></li>
<li><a href="#sec-2-1-3">链表</a></li>
<li><a href="#sec-2-1-4">队列和双队列</a></li>
<li><a href="#sec-2-1-5">集合和包</a></li>
<li><a href="#sec-2-1-6">缓存字符串</a></li>
<li><a href="#sec-2-1-7">图</a></li>
</ul>
</li>
<li><a href="#sec-2-2">数据文件和持久化</a>
<ul>
<li><a href="#sec-2-2-1">数据文件</a></li>
<li><a href="#sec-2-2-2">序列化</a></li>
</ul>
</li>
<li><a href="#sec-2-3">元数据表和元数据方法</a>
<ul>
<li><a href="#sec-2-3-1">算数元方法</a></li>
<li><a href="#sec-2-3-2">关系元方法</a></li>
<li><a href="#sec-2-3-3">库定义的方法</a></li>
<li><a href="#sec-2-3-4">Table-Access Metamethods</a></li>
</ul>
</li>
<li><a href="#sec-2-4">环境</a>
<ul>
<li><a href="#sec-2-4-1">动态命名的全局变量</a></li>
<li><a href="#sec-2-4-2">全局变量声明</a></li>
<li><a href="#sec-2-4-3">非全局环境</a></li>
<li><a href="#sec-2-4-4">使用setfenv -- Lua 5.1</a></li>
<li><a href="#sec-2-4-5">使用_ENV -- Lua 5.2</a></li>
<li><a href="#sec-2-4-6">_ENV and load</a></li>
</ul>
</li>
<li><a href="#sec-2-5">模块和包</a></li>
<li><a href="#sec-2-6">简单定义一个模块</a></li>
<li><a href="#sec-2-7">使用环境 -- lua 5.2</a></li>
<li><a href="#sec-2-8">子模块和包</a></li>
<li><a href="#sec-2-9">面向对象编程</a>
<ul>
<li><a href="#sec-2-9-1">类</a></li>
<li><a href="#sec-2-9-2">继承</a></li>
<li><a href="#sec-2-9-3">多重继承</a></li>
<li><a href="#sec-2-9-4">访问权限</a></li>
<li><a href="#sec-2-9-5">The Single-Method Approach</a></li>
</ul>
</li>
<li><a href="#sec-2-10">弱引用tables和 Finalizers</a>
<ul>
<li><a href="#sec-2-10-1">弱引用table</a></li>
<li><a href="#sec-2-10-2">备忘录(Memoize)函数</a></li>
<li><a href="#sec-2-10-3">对象属性(Object Attributes)</a></li>
<li><a href="#sec-2-10-4">优化table默认值</a></li>
<li><a href="#sec-2-10-5">Finalizers -- lua5.2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Part III: The Standard Libraries</a>
<ul>
<li><a href="#sec-3-1">数学库</a></li>
<li><a href="#sec-3-2">二进制库 -- lua 5.2</a></li>
<li><a href="#sec-3-3">Table库</a></li>
<li><a href="#sec-3-4">字符串库</a></li>
<li><a href="#sec-3-5">I/O库</a>
<ul>
<li><a href="#sec-3-5-1">简单I/O模型</a></li>
<li><a href="#sec-3-5-2">完整I/O模型</a></li>
<li><a href="#sec-3-5-3">二进制文件</a></li>
<li><a href="#sec-3-5-4">其他文件操作</a></li>
</ul>
</li>
<li><a href="#sec-3-6">系统库</a>
<ul>
<li><a href="#sec-3-6-1">日期和时间</a></li>
<li><a href="#sec-3-6-2">其他系统调用</a></li>
</ul>
</li>
<li><a href="#sec-3-7">调试库</a>
<ul>
<li><a href="#sec-3-7-1">自省机制</a></li>
<li><a href="#sec-3-7-2">钩子</a></li>
<li><a href="#sec-3-7-3">性能剖析器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Part IV: The C API</a>
<ul>
<li><a href="#sec-4-1">C API 概述</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Part I: The Language</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">开始</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Hello World
</p>
<pre class="example">
print("Hello World")
</pre>
<p>
把上边代码放入hello.lua
直接使用lua解释器运行
</p>
<div class="org-src-container">

<pre class="src src-sh">lua hello.lua
</pre>
</div>

<p>
factorial 数列
</p>
<pre class="example">
function fact (n)
  if n == 0 then
    return 1
  else
    return n * fact(n-1)
end end
print("enter a number:")
a = io.read("*n")
print(fact(a))function fact (n)
</pre>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Chunks</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
每个Lua可执行代码块, 例如一个文件，交互模式的一行，叫做chunk
</p>
<pre class="example">
a = 1
b = a * 2
a = 1;
b = a * 20
a = 1; b = a * 2
a = 1 b = a * 2 -- 难看的，但是有效的
</pre>
<p>
无参数调用直接进入交互模式
</p>
<pre class="example">
lua
</pre>
<p>
加-i 参数运行给定chunk后进入交互模式
</p>
<pre class="example">
lua -i prog
</pre>
<p>
退出交互模式，或者在程序中退出
</p>
<pre class="example">
os.exit()
</pre>
<p>
定义一个文件lib1.lua 包含以下内容
</p>
<pre class="example">
function norm (x, y)
  return (x^2 + y^2)^0.5
end

function twice (x)
  return 2*x
end
</pre>
<p>
在交互模式中
</p>
<div class="org-src-container">

<pre class="src src-sh">&gt; dofile(<span style="color: #2aa198;">"lib1.lua"</span>)   -- &#35013;&#36733;&#20320;&#23450;&#20041;&#30340;&#24211;
&gt; n = norm(3.4, 1.0)
&gt; print(twice(n))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">一些语言约定</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
标识符(Identifiers) 任意非数字开头的字母，数字，下划线组成的字符串
例如：
</p>
<pre class="example">
i   j   i10  _ij
aSomewhatLongName _INPUT
</pre>
<p>
下划线开始的标识符，有些是lua保留的(例如: _VERSION)
以下保留关键字
</p>
<pre class="example">
and       break     do        else      elseif
end       false     goto      for       function
if        in        local     nil       not
or        repeat    return    then      true
until     while
</pre>
<p>
(--) 注释开始，直到行结束
</p>
<pre class="example">
--[[
块注释
--]]
</pre>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">全局变量</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
不需要任意修饰符
例如 b = 10  b便是全局变量
</p>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">独立解释器</h4>
<div class="outline-text-4" id="text-1-1-4">
<ul class="org-ul">
<li>可执行脚本
UNIX系统：
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #93a1a1; font-style: italic;">#</span><span style="color: #93a1a1; font-style: italic;">!/usr/local/bin/lua ## lua &#35299;&#37322;&#22120;&#24517;&#39035;&#23433;&#35013;&#22312; /usr/local/</span><span style="color: #859900;">bin</span>
&#25110;&#32773;&#20351;&#29992;
<span style="color: #93a1a1; font-style: italic;">#</span><span style="color: #93a1a1; font-style: italic;">!/usr/bin/env lua</span>
</pre>
</div>
</li>
<li>lua 解释器用法
lua [options] [scritps [args]]
<ul class="org-ul">
<li>-l 装载库
% lua -l fact
</li>
<li>-e 选项 直接在控制台输入lua代码
% lua -e "print(math.sin(12))" --&gt; -0.53657291800043
</li>
<li>-i 执行完其他参数后进入交互模式
% lua -i -llib -e "x = 10"
</li>
</ul>
</li>
<li>你可以在交互模式打印任何内容 = 便可，相当于return
<div class="org-src-container">

<pre class="src src-sh">&gt; = math.sin(3)            --&gt; 0.14112000805987
&gt; a = 30
&gt; = a                      --&gt; 30
</pre>
</div>
</li>
<li>传递给脚本的参数
% lua -e "sin=math.sin" script a b
<pre class="example">
arg[-3] = "lua"
arg[-2] = "-e"
arg[-1] = "sin=math.sin"
arg[0] = "script"
arg[1] = "a"
arg[2] = "b"arg[-3]
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">类型和值</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Lua 是一种动态类型语言
</p>
<pre class="example">
print(type("Hello world"))  --&gt; string
print(type(10.4*3))         --&gt; number   
print(type(print))          --&gt; function 
print(type(type))           --&gt; function 
print(type(true))           --&gt; boolean  
print(type(nil))            --&gt; nil      
print(type(type(X)))        --&gt; string
</pre>
<p>
fucntions 在lua中是一等公民，可以像值一样处理它。
</p>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Nil</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Lua 使用nil作为一种不存在的值
</p>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Booleans</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
两种值 <b>false</b> , <b>true</b> . <b>false</b> 和 nil 为假(false), 其他都为真(true).
<b>注意</b>: lua 数字0 为真
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Numbers</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
双精度浮点数， Lua 没有整型(Integer Type).
*注意*：虽然没有Integer类型，但是可以安全的处理32位的整型数不会产生浮点摄入精度问题。
</p>
<pre class="example">
4     0.4     4.57e-3     0.3e12     5E+20
</pre>
<p>
0x 开始表示16进制数，可以使用('p' 或 'P')表示二进制指数
</p>
<pre class="example">
0xff (255)     0x1A3 (419)     0x0.2 (0.125)    0x1p-1 (0.5)
0xa.bp2 (42.75)
</pre>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Strings</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
字符串在Lua中是不可变的值(immutable values)，你不可以改变其中字符的值。每次对字符串的修改都会产生个新的值。
Lua字符串甚至可以保存二进制数据
你可以在前端加上'#'获得字符串长度
</p>
<pre class="example">
a = "hello"
print(#a)             --&gt; 5
print(#"good\0bye")   --&gt; 8
</pre>

<p>
<b>Literal strings</b>
</p>
<pre class="example">
a = "a line"
b = 'another line'
</pre>
<p>
转意
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">转意符</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">\a</td>
<td class="left">bell</td>
</tr>

<tr>
<td class="left">\b</td>
<td class="left">back space</td>
</tr>

<tr>
<td class="left">\f</td>
<td class="left">form feed</td>
</tr>

<tr>
<td class="left">\n</td>
<td class="left">newline</td>
</tr>

<tr>
<td class="left">\r</td>
<td class="left">carriage return</td>
</tr>

<tr>
<td class="left">\t</td>
<td class="left">horizontal tab</td>
</tr>

<tr>
<td class="left">\v</td>
<td class="left">vertical tab</td>
</tr>

<tr>
<td class="left">\\</td>
<td class="left">backslash</td>
</tr>

<tr>
<td class="left">\"</td>
<td class="left">double quote</td>
</tr>

<tr>
<td class="left">\'</td>
<td class="left">single quote</td>
</tr>
</tbody>
</table>

<p>
<b>Long strings</b>
</p>
<pre class="example">
page = [[
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;An HTML Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;a href="http://www.lua.org"&gt;Lua&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
]]
write(page)
</pre>
<p>
如果字符串中间包含[[]]使用 [=[xxxx]=]
</p>

<p>
<b>Coercions</b>
</p>
<pre class="example">
print("10" + 1)       --&gt; 11                            
print("10 + 1")       --&gt;10+1                           
print("-5.3e-10"*"2") --&gt; -1.06e-09                     
print("hello" + 1)    -- ERROR (cannot convert "hello") 
print(10 .. 20)       --&gt; 1020
</pre>
<p>
tonumber 把字符串转换成数字， 无法转换则返回nil
tostring 把数字转换成字符串
</p>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Tables</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
table类型是使用联合数组实现的类似map
</p>
<pre class="example">
a = {}           -- create a table and store its reference in 'a'
k = "x"
a[k] = 10        -- new entry, with key="x" and value=10
a[20] = "great"  -- new entry, with key=20 and value="great"
print(a["x"])    --&gt; 10
k = 20
print(a[k])      --&gt; "great"
a["x"] = a["x"] + 1     -- increments entry "x"
print(a["x"])    --&gt; 11
</pre>
<p>
<b>注意</b>: a[x] 使用x的值作为key
</p>
<pre class="example">
a.x = 10      -- same as a["x"] = 10   
print(a.x)    -- same as print(a["x"]) 
print(a.y)    -- same as print(a["y"])
</pre>
<p>
<b>注意</b> a.x 使用"x"字符串作为key
</p>
</div>
</div>
<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">Functions</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
函数在lua中是一等公民(first-class)，可以作为值来传递
可以调用Lua和C写的函数，所有Lua标准库是用C实现的.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7">Userdata 和 Threads</h4>
<div class="outline-text-4" id="text-1-2-7">
<p>
任意C数据可以被存储在Lua变量中
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">表达式</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">算数运算</h4>
<div class="outline-text-4" id="text-1-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">算数运算符</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">+</td>
<td class="left">addition</td>
</tr>

<tr>
<td class="left">-</td>
<td class="left">subtraction</td>
</tr>

<tr>
<td class="left">*</td>
<td class="left">multiplication</td>
</tr>

<tr>
<td class="left">^</td>
<td class="left">exponentiation</td>
</tr>

<tr>
<td class="left">%</td>
<td class="left">modulo</td>
</tr>

<tr>
<td class="left">-</td>
<td class="left">negation</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">关系运算</h4>
<div class="outline-text-4" id="text-1-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">关系运算符</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">&lt;</td>
<td class="left">小于</td>
</tr>

<tr>
<td class="left">&gt;</td>
<td class="left">大于</td>
</tr>

<tr>
<td class="left">&lt;=</td>
<td class="left">小于等于</td>
</tr>

<tr>
<td class="left">&gt;=</td>
<td class="left">大于等于</td>
</tr>

<tr>
<td class="left">==</td>
<td class="left">等于</td>
</tr>

<tr>
<td class="left">~=</td>
<td class="left">不等于</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">逻辑运算</h4>
<div class="outline-text-4" id="text-1-3-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">逻辑运算符</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">and</td>
<td class="left">与</td>
</tr>

<tr>
<td class="left">or</td>
<td class="left">或</td>
</tr>

<tr>
<td class="left">not</td>
<td class="left">非</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">连接</h4>
<div class="outline-text-4" id="text-1-3-4">
<pre class="example">
print("Hello " .. "World")  --&gt; Hello World
print(0 .. 1)               --&gt; 01
print(000 .. 01)            --&gt; 01
a = "Hello"
print(a .. " World")   --&gt; Hello World
print(a)               --&gt; Hello
</pre>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">取长度</h4>
<div class="outline-text-4" id="text-1-3-5">
<pre class="example">
print(a[#a])          -- prints the last value of sequence 'a'
a[#a] = nil           -- removes this last value              
a[#a + 1] = v         -- appends 'v' to the end of the list
</pre>
<p>
<b>注意</b> lua index是从1开始的
</p>
</div>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6">优先级</h4>
<div class="outline-text-4" id="text-1-3-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">^</td>
<td class="left">高</td>
</tr>

<tr>
<td class="left">not # - (unary)</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">+ -</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">..</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&lt; &gt; &lt;= &gt;= ~= ==</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">and</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">or</td>
<td class="left">低</td>
</tr>
</tbody>
</table>

<pre class="example">
a+i &lt; b/2+1          &lt;--&gt;  (a+i) &lt; ((b/2)+1)
5+x^2*8              &lt;--&gt;  5+((x^2)*8)
a &lt; y and y &lt;= z     &lt;--&gt;  (a&lt;y)and(y&lt;=z)
-x^2                 &lt;--&gt; -(x^2)  
x^y^z                &lt;--&gt; x^(y^z)
</pre>
</div>
</div>
<div id="outline-container-sec-1-3-7" class="outline-4">
<h4 id="sec-1-3-7">构造表</h4>
<div class="outline-text-4" id="text-1-3-7">
<pre class="example">
days = {"Sunday", "Monday", "Tuesday", "Wednesday",
             "Thursday", "Friday", "Saturday"}

a = {x=10, y=20} -- same as 
a = {}; a.x=10; a.y=20

polyline = {color="blue",
            thickness=2,
            npoints=4,
            {x=0,   y=0}, -- polyline[1] 
            {x=-10, y=0}, -- polyline[2] 
            {x=-10, y=1}, -- polyline[3] 
            {x=0,   y=1}  -- polyline[4] 
}
a = {[1]="red", [2]="green", [3]="blue",}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">程序语句</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">赋值</h4>
<div class="outline-text-4" id="text-1-4-1">
<pre class="example">
a = "hello" .. "world"
t.n = t.n + 1
a, b = 10, 2*x
x, y = y, x            -- swap 'x' for 'y'
</pre>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">本地变量和块</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
默认全局变量，local 修饰符本底变量
</p>
<pre class="example">
j = 10         -- global variable
local i = 1    -- local variable
</pre>
<p>
<b>do</b> 块 类似c中大括号
</p>
<pre class="example">
do
  local a2 = 2*a
  local d = (b^2 - 4*a*c)^(1/2)
  x1 = (-b + d)/a2
  x2 = (-b - d)/a2
end
</pre>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">流程控制语句</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
<b>if then else</b>
</p>
<pre class="example">
if a &lt; 0 then a = 0 end

if a &lt; b then return a else return b end

if line &gt; MAXLINES then
  showpage()
  line = 0
end

if op == "+" then 
  r=a+b
elseif op == "-" then 
  r=a-b
elseif op == "*" then
  r = a*b
elseif op == "/" then
  r = a/b
else
  error("invalid operation")
end
</pre>
<p>
Lua 没有 switch
</p>

<p>
<b>while</b>
</p>
<pre class="example">
local i = 1
while a[i] do
  print(a[i])
  i=i+1 
end
</pre>

<p>
<b>repeat</b>
</p>
<pre class="example">
repeat
  line = io.read()
until line ~= ""
</pre>

<p>
<b>Numeric for</b>
</p>
<pre class="example">
for var = exp1, exp2, exp3 do
  &lt;something&gt; 
end
</pre>
<p>
exp3 表示步进
如果想无限循环， 使用math.huge
</p>

<p>
<b>Generic for</b>
</p>
<pre class="example">
-- print all values of table 't'
     for k, v in pairs(t) do print(k, v) end
</pre>
</div>
</div>
<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4">break, return, and goto</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
break return 和c语言用法一样，但是Lua return 可以返回多个值
goto 在现代编程范式中并不建议使用，除非是迫不得已的情况
</p>
<pre class="example">
while some_condition do
  ::redo::
  if some_other_condition then 
    goto continue 
  elseif yet_another_condition then 
    goto redo 
  end
  &lt;some code&gt;
  ::continue::
end
</pre>

<pre class="example">
::s1:: do
  local c = io.read(1)
  if c == '0' then goto s2
  elseif c == nil then print'ok'; return
  else goto s1
  end
end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">函数</h3>
<div class="outline-text-3" id="text-1-5">
<pre class="example">
function f (a, b) print(a, b) end

f(3)         --&gt; 3      nil                     
f(3, 4)      --&gt; 3      4                       
f(3, 4, 5)   --&gt; 3      4      (5 is discarded)
</pre>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">多返回值</h4>
<div class="outline-text-4" id="text-1-5-1">
<pre class="example">
function foo0 () end                 -- returns no results
function foo1 () return "a" end      -- returns 1 result  
function foo2 () return "a", "b" end -- returns 2 results 

x,y = foo2()       -- x="a", y="b"            
x = foo2()         -- x="a", "b" is discarded 
x,y,z = 10,foo2()  -- x=10, y="a", z="b"
</pre>
<p>
(f(x)) 仅仅只会返回一个值
</p>

<p>
table.unpack 从一个数组中返回多个值 <b>Lua5.2</b>
</p>
<pre class="example">
print(table.unpack{10, 20, 30}) -&gt; 10  20 30
a, b = table.unpack{10, 20, 30}   -- a = 10, b = 20, 30 is discarded
</pre>
<p>
通常 unpack 返回数组中所有元素， 但是你可以指定返回的元素，*下标从1开始*
</p>
<pre class="example">
print(table.unpack({"Sun", "Mon", "Tue", "Wed"}, 2, 3))
  --&gt; Mon    Tue
</pre>
<p>
使用Lua实现的unpack
</p>
<pre class="example">
function unpack (t, i, n)
  i = i or 1
  n = n or #t
  if i &lt;= n then
    return t[i], unpack(t, i + 1, n)
  end
end
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">多样的函数</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
三个连续的点(...)可以提供一个参数列表 ， {...} 可以吧所有参数转换成一个数列(array)
</p>
<pre class="example">
function add (...)
  local s = 0
  for i, v in ipairs{...} do
s=s+v end
return s end
print(add(3, 4, 10, 25, 12))
--&gt; 54
</pre>
<p>
table.pack(...) 和{...} 类似， 但是有个额外的"n"来存储其其参数列表个数
通常{...}更快
</p>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">命名参数</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Lua 并不直接支持命名参数，但是可以使用table实现类似的语句结构
</p>
<pre class="example">
-- invalid code
rename(old="temp.lua", new="temp1.lua")  --这种结构并不支持

rename{old="temp.lua", new="temp1.lua"}
function rename (arg)
  return os.rename(arg.old, arg.new)
end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">更多的函数内容</h3>
<div class="outline-text-3" id="text-1-6">
<p>
在Lua中函数是一等公民,函数可以赋值个一个变量, 作为参数传递，可以作为返回值
</p>
<pre class="example">
a = {p = print}
a.p("Hello World")   --&gt; Hello World                           
print = math.sin     -- 'print' now refers to the sine function
a.p(print(1))        --&gt; 0.841470                              
sin = a.p            -- 'sin' now refers to the print function 
sin(10, 20)          --&gt; 10      20
</pre>
</div>
<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">闭包</h4>
<div class="outline-text-4" id="text-1-6-1">
<pre class="example">
names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
  return grades[n1] &gt; grades[n2]        -- compare the grades
end)
</pre>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">非全局函数</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
我们可以把函数存储在表(table)中
</p>
<pre class="example">
Lib = {}
Lib.foo = function (x,y) return x + y end
Lib.goo = function (x,y) return x - y end

Lib = {
  foo = function (x,y) return x + y end,
  goo = function (x,y) return x - y end
}

Lib = {}
function Lib.foo (x,y) return x + y end
function Lib.goo (x,y) return x - y end
</pre>
<p>
我们在定义局部变量函数是要特别小心一点
错误的代码：
</p>
<pre class="example">
local fact = function (n)
  if n == 0 then return 1
    else return n*fact(n-1)   -- buggy
  end
end
</pre>
<p>
return 语句的fact指向的是全局fact，本地fact这是还没有创建
正确的用法，先声明再赋值
</p>
<pre class="example">
local fact
fact = function (n)
  if n == 0 then return 1
    else return n*fact(n-1)
  end
pend
</pre>
<p>
或者
</p>
<pre class="example">
local function foo (&lt;params&gt;) &lt;body&gt; end
</pre>
<p>
等价与
</p>
<pre class="example">
local foo; foo = function (&lt;params&gt;) &lt;body&gt; end
</pre>
</div>
</div>

<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">恰当的尾调用</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
正确的尾调用，我们无需保持栈状态，这是Lua便做了优化
</p>
<pre class="example">
function f (x)  return g(x)  end

function foo (n)
       if n &gt; 0 then return foo(n - 1) end
end
</pre>
<p>
在尾调用递归中可以大幅度优化性能
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">迭代器和通用for</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">迭代器和闭包</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
每次调用迭代器返回下一个元素，这就需要我们使用闭包来保持迭代器状态
</p>
<pre class="example">
function values (t)
  local i = 0
  return function ()  i = i + 1; return t[i]  end
end

t = {10, 20, 30}
for element in values(t) do
  print(element)
end
</pre>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">通用for的语意</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-lua"><span style="color: #859900;">for</span> <span style="color: #dc322f; font-weight: bold;">&lt;</span><span style="color: #268bd2;">var</span><span style="color: #dc322f; font-weight: bold;">-list&gt; </span><span style="color: #859900;">in</span> &lt;exp-list&gt; <span style="color: #859900;">do</span> 
&lt;Body&gt;
<span style="color: #859900;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">无状态迭代器</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
next(t, nil) 返回t中第一个元组(pair), next(t, k) 返回k(key）下一个元组
</p>
<pre class="example">
for k, v in next, t do
  &lt;loop body&gt; 
end
</pre>
<p>
这里的状态是由k来保持的
</p>
</div>
</div>
<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4">综合状态的迭代器</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
使用table来保持多个状态
</p>
</div>
</div>
<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5">真迭代器</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
个人理解意思类似filter吧，早起版本用的比较多
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">编译执行和错误处理</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">编译</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
源文件可以编译成一种中间代码来加速执行。
类似dofile, loadfile仅仅加载一个文件，但是不会执行它，仅仅加载并比编译。
类似dofile的结构：
</p>
<pre class="example">
function dofile (filename)
  local f = assert(loadfile(filename))
  return f()
end
</pre>
<p>
我们可以使用assert来确定load file 时没有error产生。当有error产生时, assert 返回nil
</p>
<pre class="example">
assert(load(s))()
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2">预编译代码</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
使用luac预编译
</p>
<div class="org-src-container">

<pre class="src src-sh">$ luac -o prog.lc prog.lua
$ lua prog.lc
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3">C代码</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
在使用C代码库时，首先我们必须把它们链接到我们的应用中
</p>
<pre class="example">
local path = "/usr/local/lib/lua/5.1/socket.so"
local f = package.loadlib(path, "luaopen_socket")
</pre>
<p>
这里不会执行C 函数，仅仅把它们转换成Lua 函数。大多时候我们使用require加载C库
</p>
</div>
</div>
<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4">错误处理</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
可以使用error函数抛出一个error
</p>
<pre class="example">
print "enter a number:"
n = io.read("*n")
if not n then error("invalid input") end
-- 使用assert更优雅的方式
n = assert(io.read("*n"), "invalid input")
-- 或者
assert(tonumber(n), "invalid input: " .. n .. " is not a number")
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-5" class="outline-4">
<h4 id="sec-1-8-5">错误处理和异常</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
如果需要在Lua中处理errors, 必须调用pcall(protected call)来封装代码
可以使用table来封装错误信息，例如error code
</p>
<pre class="example">
local ok, msg = pcall(function ()
          &lt;some code&gt;
          if unexpected_condition then error() end
          &lt;some code&gt;
          print(a[i]) -- potential error: 'a' may not be a table &lt;some code&gt;
        end)
if ok then    -- no errors while running protected code
  &lt;regular code&gt;
else -- protected code raised an error: take appropriate action
  &lt;error-handling code&gt; 
end

local status, err = pcall(function () error({code=121}) end)
     print(err.code)  --&gt; 121
</pre>
</div>
</div>
<div id="outline-container-sec-1-8-6" class="outline-4">
<h4 id="sec-1-8-6">错误调用栈信息</h4>
<div class="outline-text-4" id="text-1-8-6">
<p>
使用debug 库
debug.debug 查看当前程序运行状态
debug.traceback 查看错误栈
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">协同程序</h3>
<div class="outline-text-3" id="text-1-9">
<p>
类似thread, 但是线程切换开销很大。使用coroutines, 不同task之间切换开销很小。
</p>
</div>
<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">协同程序基础</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
所有的相关函数都在corutine表中
创建thread
</p>
<pre class="example">
co = coroutine.create(function () print("hi") end)
print(co)   --&gt; thread: 0x8071d98
</pre>
<p>
coroutine 有四中状态suspended, running, dead, and normal
</p>
<pre class="example">
print(coroutine.status(co))   --&gt; suspended
</pre>
<p>
改变状态suspended到runing
</p>
<pre class="example">
coroutine.resume(co)  -&gt;hi
</pre>
<p>
之后coroutine state 为dead
强大的yield函数,yield 会堵塞当前线程
</p>
<pre class="example">
co = coroutine.create(function ()
       for i = 1, 10 do
         print("co", i)
         coroutine.yield()
       end
     end)
coroutine.resume(co)          --&gt; co   1
print(coroutine.status(co))   --&gt; suspended
coroutine.resume(co)          --&gt; co   2
coroutine.resume(co)          --&gt; co   3
  ...
coroutine.resume(co)          --&gt; co   10
coroutine.resume(co)          -- prints nothing
-- 再次调用返回false和一个error消息
print(coroutine.resume(co))   --&gt; false   cannot resume dead coroutine
</pre>
<p>
可以使用yield在controutine间传递值
获取controutine返回的值
</p>
<pre class="example">
co = coroutine.create(function (a,b)
       coroutine.yield(a + b, a - b)
     end)
print(coroutine.resume(co, 20, 10))  --&gt; true  30  10
</pre>
<p>
向controutine传递值
</p>
<pre class="example">
co = coroutine.create (function (x)
       print("co1", x)
       print("co2", coroutine.yield())
     end)
coroutine.resume(co, "hi")     --&gt; co1  hi
coroutine.resume(co, 4, 5)     --&gt; co2  4  5
</pre>

<pre class="example">
co = coroutine.create(function ()
       return 6, 7
     end)
print(coroutine.resume(co))   --&gt; true  6  7
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2">管道和过滤器</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
生产者消费者模式一种常用的并发编程范式
一个函数产生值（例如从一个文件读取内容）
另一个函数消费这些值（例如把这些内容写入到文件中）
例如
</p>
<pre class="example">
function receive (prod)
  local status, value = coroutine.resume(prod)
  return value
end

function send (x)
  coroutine.yield(x)
end

function producer ()
  return coroutine.create(function ()
    while true do
      local x = io.read()  -- produce new value
      send(x)
    end 
  end)
end

function filter (prod)
  return coroutine.create(function ()
    for line = 1, math.huge do
      local x = receive(prod)   -- get new value
      x = string.format("%5d %s", line, x)
      send(x)      -- send it to consumer
    end 
  end)
end

function consumer (prod)
  while true do
    local x = receive(prod) -- get new value
    io.write(x, "\n") -- consume new value
  end
end

consumer(filter(producer))
</pre>
<p>
如果你很熟悉Unix pipes，上边的编程范式感觉并不陌生。
</p>
</div>
</div>
<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3">把协同程序作为迭代器</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
coroutine.wrap 和coroutine.create类似，但是它返回一个函数，当我们调用此函数时类似对所创建的coroutine执行
resume， 但不会返回状态信息，也无法检测运行时错误。
</p>
<pre class="example">
function permgen (a, n)
     n = n or #a          -- default for 'n' is size of 'a'
     if n &lt;= 1 then       -- nothing to change?
       coroutine.yield(a)
     else
       for i = 1, n do
         -- put i-th element as the last one
         a[n], a[i] = a[i], a[n]
         -- generate all permutations of the other elements
         permgen(a, n - 1)
         -- restore i-th element
         a[n], a[i] = a[i], a[n]
       end 
     end
end

function permutations(a)
  return coroutine.wrap(function () permgen(a) end)
end

function printResult (a)
   for i = 1, #a do
      io.write(a[i], " ")
   end
   io.write("\n")
end

for p in permutations{"a", "b", "c"} do 
  printResult(p)
end
--&gt; b c a
--&gt; c b a
--&gt; c a b
--&gt; a c b
--&gt; b a c
--&gt; a b c
</pre>
</div>
</div>
<div id="outline-container-sec-1-9-4" class="outline-4">
<h4 id="sec-1-9-4">非抢占式多线程</h4>
<div class="outline-text-4" id="text-1-9-4">
<p>
我们来实现一个多线程下载程序，socket库需要我们自己安装
</p>
<pre class="example">
local socket = require "socket"

function download (host, file)
   local c = assert(socket.connect(host, 80))
   local count = 0    -- counts number of bytes read
   c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
   while true do
      local s, status = receive(c)
      count = count + #s
      if status == "closed" then break end
   end
   c:close()
   print(file, count)
end
   
function receive (connection)
   connection:settimeout(10)
   local s, status, partial = connection:receive(2^10)
   if status == "timeout" then
      coroutine.yield(connections)
   end
   return s or partial, status
end

threads = {} -- list of all live threads
function get (host, file)
   -- create coroutine
   local co = coroutine.create(function ()
         download(host, file)
   end)
   -- insert it in the list
   table.insert(threads, co)
end

function dispatch ()
   local i = 1
   local timedout = {}
   while true do
      if threads[i] == nil then
         if threads[1] == nil then break end
         i = 1                     -- restart the loop
         timedout = {}
      end
      local status, res = coroutine.resume(threads[i])
      if not res then    -- thread finished its task?
         table.remove(threads, i)
      else               -- time out
         i=i+1
         timedout[#timedout + 1] = res
         if #timedout == #threads then
            socket.select(timedout)
         end
      end
   end
end


host = "www.w3.org"
get(host, "/TR/html401/html40.txt")
get(host, "/TR/2002/REC-xhtml1-20020801/xhtml1.pdf")
get(host, "/TR/REC-html32.html")
get(host, "/TR/2000/REC-DOM-Level-2-Core-20001113/DOM2-Core.txt")
dispatch()   -- main loop
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Part II: Table and Objects</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">数据结构</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">数组</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Lua中把table作为Array只不过index为integers.
</p>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">矩阵多维数组</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>第一种方式多维嵌套的
<pre class="example">
mt={}
for i = 1, N do
  mt[i] = {}
  for j = 1, M do
    mt[i][j] = 0
  end
end
</pre>
</li>
<li>第二种方式本质上还是一维的
<pre class="example">
mt = {} -- create the matrix 
for i = 1, N do
  for j = 1, M do
    mt[(i - 1)*M + j] = 0
  end 
end
</pre>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">链表</h4>
<div class="outline-text-4" id="text-2-1-3">
<pre class="example">
list = nil
list = {next = list, value = v}
local l = list
  while l do
    &lt;visit l.value&gt;
    l = l.next 
end
</pre>
</div>
</div>
<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4">队列和双队列</h4>
<div class="outline-text-4" id="text-2-1-4">
<pre class="example">
List = {}
function List.new ()
  return {first = 0, last = -1}
     end
function List.pushfirst (list, value)
       local first = list.first - 1
       list.first = first
       list[first] = value
end
function List.pushlast (list, value)
  local last = list.last + 1
  list.last = last
  list[last] = value
end
function List.popfirst (list)
  local first = list.first
  if first &gt; list.last then error("list is empty") end
  local value = list[first]
  list[first] = nil        -- to allow garbage collection
  list.first = first + 1
  return value
end
function List.poplast (list)
  local last = list.last
  if list.first &gt; last then error("list is empty") end
  local value = list[last]
  list[last] = nil         -- to allow garbage collection
  list.last = last - 1
  return value
end
</pre>
</div>
</div>
<div id="outline-container-sec-2-1-5" class="outline-4">
<h4 id="sec-2-1-5">集合和包</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
Set把table的key作为存储， 其值为true
</p>
<pre class="example">
reserved = {
  ["while"] = true,     ["end"] = true,
  ["function"] = true,  ["local"] = true,
}
for w in allwords() do
  if not reserved[w] then
  &lt;do something with ’w’&gt; end
end


function Set (list)
  local set = {}
  for _, l in ipairs(list) do set[l] = true end
  return set
end
reserved = Set{"while", "end", "function", "local", }
</pre>
<p>
Bag和set不同其值可以出现多次，类似set把table的key作为存储， 其值为count
</p>
<pre class="example">
function insert (bag, element)
  bag[element] = (bag[element] or 0) + 1
end
function remove (bag, element)
  local count = bag[element]
  bag[element] = (count and count &gt; 1) and count - 1 or nil
end
</pre>
</div>
</div>
<div id="outline-container-sec-2-1-6" class="outline-4">
<h4 id="sec-2-1-6">缓存字符串</h4>
<div class="outline-text-4" id="text-2-1-6">
<p>
拼接字符串，大数据处理时代价相当高
</p>
<pre class="example">
local buff = ""
for line in io.lines() do
  buff = buff .. line .. "\n"
end
</pre>

<p>
使用table.concat(t)函数
</p>
<pre class="example">
local t = {}
for line in io.lines() do
  t[#t + 1] = line .. "\n"
end
local s = table.concat(t)

local t = {}
     for line in io.lines() do
       t[#t + 1] = line
     end
     s = table.concat(t, "\n") .. "\n"
</pre>
</div>
</div>
<div id="outline-container-sec-2-1-7" class="outline-4">
<h4 id="sec-2-1-7">图</h4>
<div class="outline-text-4" id="text-2-1-7">
<pre class="example">
local function name2node (graph, name)
  local node = graph[name]
  if not node then
    -- node does not exist; create a new one
    node = {name = name, adj = {}}
    graph[name] = node
  end
  return node
end

function readgraph ()
  local graph = {}
  for line in io.lines() do
    -- split line in two names
    local namefrom, nameto = string.match(line, "(%S+)%s+(%S+)")
    -- find corresponding nodes
    local from = name2node(graph, namefrom)
    local to = name2node(graph, nameto)
    -- adds 'to' to the adjacent set of 'from'
    from.adj[to] = true
  end
  return graph
end

function findpath (curr, to, path, visited)
  path = path or {}
  visited = visited or {}
  if visited[curr] then   -- node already visited?
    return nil            -- no path here         
  end
  visited[curr] = true    -- mark node as visited 
  path[#path + 1] = curr  -- add it to path       
  if curr == to then      -- final node?          
    return path
  end
  -- try all adjacent nodes
  for node in pairs(curr.adj) do
    local p = findpath(node, to, path, visited)
    if p then return p end
  end
  path[#path] = nil         -- remove node from path
end
function printpath (path)
  for i = 1, #path do
    print(path[i].name)
  end
end
g = readgraph()
a = name2node(g, "a")
b = name2node(g, "b")
p = findpath(a, b)
if p then printpath(p) end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">数据文件和持久化</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">数据文件</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
通常我们使用csv, xml存储数据文件，这里我们直接使用lua代码
例如一个data文件:
</p>
<pre class="example">
Entry{
  author = "Donald E. Knuth",
  title = "Literate Programming",
  publisher = "CSLI",
  year = 1992
}
Entry{
  author = "Jon Bentley",
  title = "More Programming Pearls",
  year = 1990,
  publisher = "Addison-Wesley",
}
</pre>
<p>
<b>Entry{code} is same as Entry({code})</b>
直接使用dofile读取
</p>
<pre class="example">
local authors = {}      -- a set to collect authors
function Entry (b)
  if b.author then authors[b.author] = true end
end
dofile("data")
for name in pairs(authors) do print(name) end
</pre>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">序列化</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
<b>小心处理字符串转义和table循环引用</b>
</p>
<pre class="example">
function basicSerialize (o)
  if type(o) == "number" then
    return tostring(o)
  else   -- assume it is a string
    return string.format("%q", o)
  end
end
function save (name, value, saved)
  saved = saved or {}
  io.write(name, " = ")
  if type(value) == "number" or type(value) == "string" then
    io.write(basicSerialize(value), "\n")
  elseif type(value) == "table" then
    if saved[value] then                  -- value already saved?  
      io.write(saved[value], "\n")        -- use its previous name 
    else
      saved[value] = name                 -- save name for next time 
      io.write("{}\n")                    -- create a new table      
      for k,v in pairs(value) do          -- save its fields         
        k = basicSerialize(k)
        local fname = string.format("%s[%s]", name, k)
        save(fname, v, saved)
      end 
    end
  else
    error("cannot save a " .. type(value))
  end 
end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">元数据表和元数据方法</h3>
<div class="outline-text-3" id="text-2-3">
<p>
使用Metatales我们可以实现运算符重载
<b>Metatalbe仅仅用在table中</b> 其他类型我们必须使用c代码实现
</p>
<pre class="example">
t = {}
print(getmetatable(t))   --&gt; nil
t1 = {}
setmetatable(t, t1)
print(getmetatable(t) == t1)   --&gt; true
</pre>
<p>
使用metable 添加Metamethods
</p>
<pre class="example">
local mt = {}    -- metatable for sets
function Set.new (l)   -- 2nd version
  local set = {}
  setmetatable(set, mt)
  for _, v in ipairs(l) do set[v] = true end
  return set
end
mt.__add = Set.union
mt.__mul = Set.intersection
Set = {}
   -- create a new set with the values of a given list
function Set.new (l)
  local set = {}
  for _, v in ipairs(l) do set[v] = true end
  return set
end
function Set.union (a, b)
  if getmetatable(a) ~= mt or getmetatable(b) ~= mt then
    error("attempt to 'add' a set with a non-set value", 2)
  end
  local res = Set.new{}
  for k in pairs(a) do res[k] = true end
  for k in pairs(b) do res[k] = true end
  return res
end
function Set.intersection (a, b)
  if getmetatable(a) ~= mt or getmetatable(b) ~= mt then
    error("attempt to 'add' a set with a non-set value", 2)
  end
  local res = Set.new{}
  for k in pairs(a) do
    res[k] = b[k]
  end
  return res
end
-- presents a set as a string
function Set.tostring (set)
  local l = {}     -- list to put all elements from the set
  for e in pairs(set) do
    l[#l + 1] = e
  end
  return "{" .. table.concat(l, ", ") .. "}"
end
-- print a set
function Set.print (s)
  print(Set.tostring(s))
end
</pre>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">算数元方法</h4>
<div class="outline-text-4" id="text-2-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Metamethods</th>
<th scope="col" class="left">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">__add</td>
<td class="left">+</td>
</tr>

<tr>
<td class="left">__mul</td>
<td class="left">*</td>
</tr>

<tr>
<td class="left">__sub</td>
<td class="left">-</td>
</tr>

<tr>
<td class="left">__div</td>
<td class="left">/</td>
</tr>

<tr>
<td class="left">__unm</td>
<td class="left">-</td>
</tr>

<tr>
<td class="left">__mod</td>
<td class="left">%</td>
</tr>

<tr>
<td class="left">__pow</td>
<td class="left">^</td>
</tr>

<tr>
<td class="left">__concat</td>
<td class="left">..</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">关系元方法</h4>
<div class="outline-text-4" id="text-2-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Metamethods</th>
<th scope="col" class="left">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">__eq</td>
<td class="left">==</td>
</tr>

<tr>
<td class="left">__lt</td>
<td class="left">&lt;</td>
</tr>

<tr>
<td class="left">__le</td>
<td class="left">&lt;=</td>
</tr>
</tbody>
</table>
<p>
其他的Lua转换 a~=b 到 not(a==b), a&gt;b 到 b&lt;a，和 a&gt;=b 到b&lt;=a
</p>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">库定义的方法</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
__tostring
</p>
</div>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">Table-Access Metamethods</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
__index, __newindex
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">环境</h3>
<div class="outline-text-3" id="text-2-4">
<p>
所有的全局变量在 _G (_G._G equal to _G)table中存储
</p>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">动态命名的全局变量</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
使用table来访问全局变量
value = _G[varname]
</p>
<pre class="example">
function getfield (f)
  local v = _G    -- start with the table of globals
  for w in string.gmatch(f, "[%w_]+") do
    v = v[w] 
  end
  return v 
end
function setfield (f, v)
  local t = _G            -- start with the table of globals
  for w, d in string.gmatch(f, "([%w_]+)(%.?)") do
    if d == "." then
      t[w] = t[w] or {}
      t = t[w]
    else
      t[w] = v
    end 
  end
end
</pre>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">全局变量声明</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
全部变量不需要声明，但有时引起的bug很难找，我们可以使用metatable改变默认行为
#+BEG
setmetatable(_G, {
  <span class="underline">_newindex = function (</span>, n)
    error("attempt to write to undeclared variable " .. n, 2)
  end,
  <span class="underline">_index = function (</span>, n)
    error("attempt to read undeclared variable " .. n, 2)
  end, 
})
&gt; print(a)
     stdin:1: attempt to read undeclared variable a
function declare (name, initval)
       rawset(_G, name, initval or false)
end
#+END_SRC
</p>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">非全局环境</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
上一节我们改变里全局变量的默认行为，但是当我们引入一个新库，使用旧有的机制时，边可能产生问题，
我们可以改变某个库或函数默认的全局变量读取，来解决这个问题
</p>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">使用setfenv -- Lua 5.1</h4>
<div class="outline-text-4" id="text-2-4-4">
<pre class="example">
setfenv(1, {}) 空的全局变量
setfenv(1, {g= _G}) 改变当前环境
</pre>
</div>
</div>
<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5">使用_ENV -- Lua 5.2</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
创建新的环境变量
</p>
<pre class="example">
_ENV = {g = {}} -- 新的空的环境变量
</pre>
</div>
</div>
<div id="outline-container-sec-2-4-6" class="outline-4">
<h4 id="sec-2-4-6">_ENV and load</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
load 库时使用新的环境
</p>
<pre class="example">
env = {}
f = loadfile("config.lua", "t", env)
f()
#+END_SRC lua
debug设置新的环境
#+BEGIN_SRC 
f = loadfile(filename)
p    ...
env = {}
debug.setupvalue(f, 1, env)
</pre>
<p>
loadwithprefix
</p>
<pre class="example">
f = loadwithprefix("local _ENV = ...;", io.lines(filename, "*L"))
...
env = {}
f(env)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">模块和包</h3>
<div class="outline-text-3" id="text-2-5">
<p>
标准库是Modules, 使用 
</p>
<pre class="example">
socks = require "socks"
</pre>
<ul class="org-ul">
<li>require 函数
</li>
</ul>
<p>
简单的调用 require "&lt;模块名&gt;"返回由模块函数组成的table.
</p>
<ul class="org-ul">
<li>重命名模块 -- Lua 5.2
</li>
</ul>
<p>
TODO 没理解
</p>
<ul class="org-ul">
<li>搜索路径Path
</li>
</ul>
<p>
LUA_PATH_5_2 &gt; LUA_PATH &gt; compiled-defined default path
?为通配符
</p>
<pre class="example">
./?.so;/usr/local/lib/lua/5.2/?.so
</pre>
<ul class="org-ul">
<li>Searchers -- Lua 5.2
</li>
</ul>
<p>
package.searchers
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">简单定义一个模块</h3>
<div class="outline-text-3" id="text-2-6">
<p>
把模块函数放到一个table中返回便可。
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">使用环境 -- lua 5.2</h3>
<div class="outline-text-3" id="text-2-7">
<p>
M.add
</p>
<div class="org-src-container">

<pre class="src src-lu">local M = {}
_ENV = M
function add (c1, c2)
  return new(c1.r + c2.r, c1.i + c2.i)
end
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">子模块和包</h3>
<div class="outline-text-3" id="text-2-8">
<p>
mod.sub sub是mod的子模块
require "a.b" 查找文件 a_b.lua
</p>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">面向对象编程</h3>
<div class="outline-text-3" id="text-2-9">
<p>
lua 面向对象和javascript有点像都是使用prototype
</p>
</div>
<div id="outline-container-sec-2-9-1" class="outline-4">
<h4 id="sec-2-9-1">类</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
一个类还是一个table, 将其做为新建对象或类的metatable
</p>
<pre class="example">
Account = {}
function Account:new (o)
  o = o or {}     -- create table if user does not provide one
  setmetatable(o, self)
  self.__index = self -- 这个是必须的，回顾metatable __index元方法
  return o
end
function Account:deposit (v)
  self.balance = self.balance + v
end
function Account:withdraw (v)
  if v &gt; self.balance then error"insufficient funds" end
  self.balance = self.balance - v
end
a = Account:new{balance = 0}
a:deposit(100.00)
</pre>
</div>
</div>
<div id="outline-container-sec-2-9-2" class="outline-4">
<h4 id="sec-2-9-2">继承</h4>
<div class="outline-text-4" id="text-2-9-2">
<pre class="example">
SpecialAccount = Account:new()
function SpecialAccount:withdraw (v)
  if v - self.balance &gt;= self:getLimit() then
    error"insufficient funds"
  end
  self.balance = self.balance - v
end
function SpecialAccount:getLimit ()
  return self.limit or 0
end
s = SpecialAccount:new{limit=1000.00}
</pre>
</div>
</div>
<div id="outline-container-sec-2-9-3" class="outline-4">
<h4 id="sec-2-9-3">多重继承</h4>
<div class="outline-text-4" id="text-2-9-3">
<pre class="example">
Named = {}
function Named:getname ()
  return self.name
end
function Named:setname (n)
  self.name = n
end
-- look up for 'k' in list of tables 'plist'
local function search (k, plist)
  for i = 1, #plist do
   local v = plist[i][k]
   if v then return v end
  end 
end
-- try 'i'-th superclass
function createClass (...)
  local c = {}        -- new class
  local parents = {...}
  -- class will search for each method in the list of its parents
  setmetatable(c, {__index = function (t, k)
    local v = search(k, parents)
    t[k] = v           --improve performance
    return v
  end})
  -- prepare 'c' to be the metatable of its instances
  c.__index = c
  -- define a new constructor for this new class
  function c:new (o)
    o = o or {}
    setmetatable(o, c)
    return o
  end
  return c -- return new class
end
NameAccount = createClass(Account, Named)
account = NamedAccount:new{name = "Paul"}
print(account:getname())     --&gt; Paul
</pre>
</div>
</div>
<div id="outline-container-sec-2-9-4" class="outline-4">
<h4 id="sec-2-9-4">访问权限</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
可以用Local变量变相实现私有成员函数
</p>
</div>
</div>
<div id="outline-container-sec-2-9-5" class="outline-4">
<h4 id="sec-2-9-5">The Single-Method Approach</h4>
<div class="outline-text-4" id="text-2-9-5">
<pre class="example">
function newObject (value)
  return function (action, v)
    if action == "get" then return value
    elseif action == "set" then value = v
    else error("invalid action")
    end
  end 
end
d = newObject(0)
print(d("get"))   --&gt; 0  
d("set", 10)      
print(d("get"))   --&gt; 10
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">弱引用tables和 Finalizers</h3>
<div class="outline-text-3" id="text-2-10">
</div><div id="outline-container-sec-2-10-1" class="outline-4">
<h4 id="sec-2-10-1">弱引用table</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
我们可以指定table中key，value 或两者都是弱引用，
其中任意被垃圾回收器删除时，整个条目就会被删除
使用metatable的__mode 值来表示 
</p>
<ul class="org-ul">
<li>__mode = "k" 表示 key 为弱引用
</li>
<li>__mode = "v" 表示 value 为弱引用
</li>
<li>__mode = "kv" 表示 key 和 value 都是弱引用
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10-2" class="outline-4">
<h4 id="sec-2-10-2">备忘录(Memoize)函数</h4>
<div class="outline-text-4" id="text-2-10-2">
<p>
"空间换取时间"提高性能技术, 一种缓存方法
</p>
<pre class="example">
local results = {}
setmetatable(results, {__mode = "v"})  -- make values weak
function createRGB (r, g, b)
  local key = r .. "-" .. g .. "-" .. b
  local color = results[key]
  if color == nil then
    color = {red = r, green = g, blue = b}
    results[key] = color
  end
  return color
end
</pre>
</div>
</div>
<div id="outline-container-sec-2-10-3" class="outline-4">
<h4 id="sec-2-10-3">对象属性(Object Attributes)</h4>
<div class="outline-text-4" id="text-2-10-3">
<p>
弱引用table另外一项重要应用是将属性与对象关联起来，例如
我们不想扰乱原table的遍历，把某些属性存储在外部table中(使用弱引用Key)，
其原table被回收时，对应属性也会自动回收
</p>
</div>
</div>
<div id="outline-container-sec-2-10-4" class="outline-4">
<h4 id="sec-2-10-4">优化table默认值</h4>
<div class="outline-text-4" id="text-2-10-4">
<ul class="org-ul">
<li>使用弱引用key的table存储默认值
<pre class="example">
local defaults = {}
setmetatable(defaults, {__mode = "k"})
local mt = {__index = function (t) return defaults[t] end}
function setDefault (t, d)
  defaults[t] = d
  setmetatable(t, mt)
end
</pre>
</li>
<li>使用容引用Value的table存储默认值
<pre class="example">
local metas = {}
setmetatable(metas, {__mode = "v"})
function setDefault (t, d)
  local mt = metas[d]
  if mt == nil then
    mt = {__index = function () return d end}
    metas[d] = mt     -- memorize
  end
  setmetatable(t, mt)
end
</pre>
</li>
</ul>
<p>
两者性能没有太大差别，根据系统存在默认值数量取舍
</p>
</div>
</div>
<div id="outline-container-sec-2-10-5" class="outline-4">
<h4 id="sec-2-10-5">Finalizers -- lua5.2</h4>
<div class="outline-text-4" id="text-2-10-5">
<p>
__gc 元方法在gc回收对象时调用
setmetatable(o, mt)之前设置，否则不会应用
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Part III: The Standard Libraries</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">数学库</h3>
<div class="outline-text-3" id="text-3-1">
<p>
math.xxx
三角函数(sin, cos, tan, asin, acos 等)，使用弧度单位
指数和对数函数(exp, log, log10)
取整函数(floor, ceil), max 和 min
伪随机数(random, randomseed), 以及变量pi 和 huge(Lua最大表示数字)
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">二进制库 -- lua 5.2</h3>
<div class="outline-text-3" id="text-3-2">
<p>
bit32.xxx
band,bor,bxor,bnot
string.format("0x%X", x)
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Table库</h3>
<div class="outline-text-3" id="text-3-3">
<p>
table.xxx
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">insert(t, index ,value)</td>
<td class="left">index 默认值为#t + 1</td>
</tr>

<tr>
<td class="left">remove(t, index)</td>
<td class="left">index 默认值为#t</td>
</tr>

<tr>
<td class="left">sort(t)</td>
<td class="left">t的value 升序排序</td>
</tr>

<tr>
<td class="left">concat(s)</td>
<td class="left">使用s作为连字符连接成字符串，默认空</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">字符串库</h3>
<div class="outline-text-3" id="text-3-4">
<p>
string.xxx
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">upper(s)</td>
<td class="left">转换成大写</td>
</tr>

<tr>
<td class="left">lower(s)</td>
<td class="left">转换成小写</td>
</tr>

<tr>
<td class="left">sub(s, i, j)</td>
<td class="left">第i到第j字符，可为复数，-1表示最后一个字符</td>
</tr>

<tr>
<td class="left">char(integer)</td>
<td class="left">内部表示数字转换成字符</td>
</tr>

<tr>
<td class="left">byte(s, i)</td>
<td class="left">s,第i字符转换成 内部表示的数字，i默认为1</td>
</tr>

<tr>
<td class="left">format(s, v1, v2)</td>
<td class="left">格式化字符串类似c语言的format</td>
</tr>
</tbody>
</table>
<p>
模式匹配(pattern-matching)
不同于其他脚本语言，lua没有使用POSIX(regexp),也没有使用Perl的正则表达式进行模式匹配
其主要原因是考虑到lua的大小
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">find(s, p, i)</td>
<td class="left">返回p在s中起始和结束位置, i为起始查找位置默认为1</td>
</tr>

<tr>
<td class="left">match(s, p, i)</td>
<td class="left">返回s中匹配p的字符串，i为起始查找位置默认为1</td>
</tr>

<tr>
<td class="left">gsub(s, p, s1, n)</td>
<td class="left">返回一个字符串，把s中符合p的内容替换为s1, n限制替换次数，默认不限制</td>
</tr>

<tr>
<td class="left">gmatch(s, p)</td>
<td class="left">返回一个迭代器函数，遍历s中符合p模式的字符串</td>
</tr>
</tbody>
</table>
<p>
模式
字符分类
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">.</td>
<td class="left">所有字符</td>
</tr>

<tr>
<td class="left">%a</td>
<td class="left">字母</td>
</tr>

<tr>
<td class="left">%c</td>
<td class="left">控制字符</td>
</tr>

<tr>
<td class="left">%d</td>
<td class="left">数字</td>
</tr>

<tr>
<td class="left">%l</td>
<td class="left">小写字符</td>
</tr>

<tr>
<td class="left">%g</td>
<td class="left">其他可打印字符</td>
</tr>

<tr>
<td class="left">%p</td>
<td class="left">标点符号</td>
</tr>

<tr>
<td class="left">%s</td>
<td class="left">空白字符</td>
</tr>

<tr>
<td class="left">%u</td>
<td class="left">大写字母</td>
</tr>

<tr>
<td class="left">%w</td>
<td class="left">字母和数字</td>
</tr>

<tr>
<td class="left">%x</td>
<td class="left">十六进制数字</td>
</tr>

<tr>
<td class="left">()</td>
<td class="left">表示位置</td>
</tr>
</tbody>
</table>
<p>
重复次数
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">+</td>
<td class="left">1或多次</td>
</tr>

<tr>
<td class="left">*</td>
<td class="left">0或多次</td>
</tr>

<tr>
<td class="left">-</td>
<td class="left">0或多次非贪婪</td>
</tr>

<tr>
<td class="left">？</td>
<td class="left">0或1次</td>
</tr>
</tbody>
</table>
<p>
使用%来转义 "(",")"和"."
URL编码
</p>
<pre class="example">
function escape (s)
  s = string.gsub(s, "[&amp;=+%%%c]", function (c)
        return string.format("%%%02X", string.byte(c))
      end)
  s = string.gsub(s, " ", "+")
  return s 
end
function encode (t)
  local b = {}
  for k,v in pairs(t) do
    b[#b + 1] = (escape(k) .. "=" .. escape(v))
  end
  return table.concat(b, "&amp;")
end
t={name="al", query="a+b=c",q="yesorno"} 
print(encode(t)) --&gt; q=yes+or+no&amp;query=a%2Bb+%3D+c&amp;name=al
function unescape (s)
  s = string.gsub(s, "+", " ")
  s = string.gsub(s, "%%(%x%x)", function (h)
        return string.char(tonumber(h, 16))
      end)
  return s 
end
cgi = {}
function decode (s)
  for name, value in string.gmatch(s, "([^&amp;=]+)=([^&amp;=]+)") do
    name = unescape(name)
    value = unescape(value)
    cgi[name] = value
  end 
end
</pre>
<p>
Unicode
\xxx
</p>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">I/O库</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">简单I/O模型</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
i/o默认初始化的输入文件为stdin，输出文件为stdout, 使用io.input, io.output改变两个文件。
或者使用io.open,io.write 写,io.read 读
</p>

<p>
io.read 读取模式
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">*all</td>
<td class="left">读取整个文件</td>
</tr>

<tr>
<td class="left">*line</td>
<td class="left">读取下一行</td>
</tr>

<tr>
<td class="left">*number</td>
<td class="left">读取一个数字</td>
</tr>

<tr>
<td class="left">&lt;num&gt;</td>
<td class="left">读取不超过&lt;num&gt;个字符的字符串</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">完整I/O模型</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
完整模型是基于文件句病的，它等价于C语言中的流(FILE*)，表示一个具有当前位置的打开文件
io.open(filename, mode)
类似C语言中的fopen函数, mode:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">r</td>
<td class="left">读取</td>
</tr>

<tr>
<td class="left">w</td>
<td class="left">吸入（会删除原来的内容）</td>
</tr>

<tr>
<td class="left">a</td>
<td class="left">追加</td>
</tr>

<tr>
<td class="left">b</td>
<td class="left">打开二进制文件</td>
</tr>
</tbody>
</table>
<p>
I/O库预定义了3个C语言流的句柄：io.stdin, io.stdout, io.stderr
</p>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">二进制文件</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
io.input, io.output 总是以文本的方式打开文件。
在Unix中，二进制文件和文本文件是没有差别的，但是Windows中，必须用二进制模式打开二进制文件。
Lua中二进制数据的处理与文本处理类似。Lua中的字符串可能包含任意字节，库中几乎所有函数都能处理任意字节。
值为零的字节，转意%z来表示
</p>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4">其他文件操作</h4>
<div class="outline-text-4" id="text-3-5-4">
<p>
函数flush会将缓冲区的数据写入文件
函数seek可以获取和设置文件当前位置，f:seek(whence, offset)
whence是一个字符串
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">set</td>
<td class="left">文件起始</td>
</tr>

<tr>
<td class="left">cur</td>
<td class="left">当前位置</td>
</tr>

<tr>
<td class="left">en</td>
<td class="left">文件末尾</td>
</tr>
</tbody>
</table>
<p>
函数的返回值与whence无关，相对于文件起始位置偏移字节数。
whence,offset 默认值为"cur", 0, f:seek() 并不会改变当前位置，仅仅返回当前位置。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">系统库</h3>
<div class="outline-text-3" id="text-3-6">
</div><div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">日期和时间</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
函数time和date提供了所有的日期和时间功能。
time返回当前时间的秒数，以1970年月1日00:00:00 UTC 开始。可以有一个表示日期时间的table参数。
data返回表示日期的table或格式化字符串，取决于参数标记值
描述日期和时间的table：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">year</td>
<td class="right"><b>**</b></td>
</tr>

<tr>
<td class="left">month</td>
<td class="right">01-12</td>
</tr>

<tr>
<td class="left">day</td>
<td class="right">01-31</td>
</tr>

<tr>
<td class="left">hour</td>
<td class="right">00-23</td>
</tr>

<tr>
<td class="left">min</td>
<td class="right">00-59</td>
</tr>

<tr>
<td class="left">sec</td>
<td class="right">00-59</td>
</tr>

<tr>
<td class="left">isdst</td>
<td class="right">布尔值，true表示夏令时</td>
</tr>
</tbody>
</table>
<p>
如果没有时间字段默认为中午12:00:00
</p>

<p>
如果参数为"*t"返回表示时间的table, 格式化字符串返回格式化后的日期字符串
data参数格式化字符串标记含义
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">%a</td>
<td class="left">星期简写  Wed</td>
</tr>

<tr>
<td class="left">%A</td>
<td class="left">星期 Wednesday</td>
</tr>

<tr>
<td class="left">%b</td>
<td class="left">月份简写 Sep</td>
</tr>

<tr>
<td class="left">%B</td>
<td class="left">月份 September</td>
</tr>

<tr>
<td class="left">%c</td>
<td class="left">日期和时间 (09/16/98 23:48:10)</td>
</tr>

<tr>
<td class="left">%d</td>
<td class="left">几号</td>
</tr>

<tr>
<td class="left">%H</td>
<td class="left">24制小时</td>
</tr>

<tr>
<td class="left">%h</td>
<td class="left">12制小时</td>
</tr>

<tr>
<td class="left">%j</td>
<td class="left">全年第几天</td>
</tr>

<tr>
<td class="left">%M</td>
<td class="left">分钟</td>
</tr>

<tr>
<td class="left">%m</td>
<td class="left">月份</td>
</tr>

<tr>
<td class="left">%p</td>
<td class="left">am or pm</td>
</tr>
</tbody>
</table>

<p>
os.clock 返回当前cpu秒数，通常计算程序运行时间
</p>
</div>
</div>
<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">其他系统调用</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
os.xxx
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">exit</td>
<td class="left">终止程序</td>
</tr>

<tr>
<td class="left">getenv</td>
<td class="left">返回给定环境变量的值</td>
</tr>

<tr>
<td class="left">execute</td>
<td class="left">和C中system类似， 执行系统命令，返回状态代码</td>
</tr>

<tr>
<td class="left">setlocale</td>
<td class="left">设置区域</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">调试库</h3>
<div class="outline-text-3" id="text-3-7">
<p>
调试库由两类函数组成：自省函数（introspective function）和 钩子(hook)。
</p>
</div>
<div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1">自省机制</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
主要的自省函数是debug.getinfo. 第一个参数可以是一个函数或栈层。
debug.getinfo(foo)得到一个table,其字段为：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">source</td>
<td class="left">通过loadstring加载则是这个字符串，或文件名加前缀@</td>
</tr>

<tr>
<td class="left">short_src</td>
<td class="left">最多60个字符source</td>
</tr>

<tr>
<td class="left">linedefined</td>
<td class="left">函数定义起始行</td>
</tr>

<tr>
<td class="left">lastlinedefined</td>
<td class="left">函数定义最后一行</td>
</tr>

<tr>
<td class="left">what</td>
<td class="left">"Lua" 或 "C" 或 "main"</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">该函数名字</td>
</tr>

<tr>
<td class="left">namewhat</td>
<td class="left">"global", "local", "method", "filed" 或 ""</td>
</tr>

<tr>
<td class="left">nups</td>
<td class="left">该函数upvalue数量</td>
</tr>

<tr>
<td class="left">activelines</td>
<td class="left">一个table 包含该函数所有代码行</td>
</tr>

<tr>
<td class="left">func</td>
<td class="left">函数本身</td>
</tr>

<tr>
<td class="left">currentline</td>
<td class="left">调用栈执行的行号，仅在参数为n是有</td>
</tr>
</tbody>
</table>

<p>
debug.getinfo(n), 返回相应栈上函数的数据。
第二个可选参数指定获取的字段以提高性能
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">n</td>
<td class="left">name， namewhat</td>
</tr>

<tr>
<td class="left">f</td>
<td class="left">func</td>
</tr>

<tr>
<td class="left">S</td>
<td class="left">source, short_src, what, linedefined, lastlinedefined</td>
</tr>

<tr>
<td class="left">l</td>
<td class="left">currentline</td>
</tr>

<tr>
<td class="left">L</td>
<td class="left">activelines</td>
</tr>

<tr>
<td class="left">u</td>
<td class="left">nups</td>
</tr>
</tbody>
</table>

<p>
还有个debug.traceback函数
</p>
<ul class="org-ul">
<li>访问局部变量(Accessing local variables)
debug.getlocal查看任意活动函数的局部变量， 该函数有两个参数，栈层和变量索引，返回变量名和当前值。
不存在则返回nil,如果栈层是无效的会引发一个错误，可以使用debug.getinfo来检查栈层是否有效。
debug.setlocal设置局部变量的值，第三个参数为新值
</li>
<li>访问非局部变量(non-local varible)
getupvalue,第一个参数不是栈层，而是个closure。setupvalue用来修改。
</li>
<li>访问其他协同程序(Accessing other coroutines)
调试库中所有自省函数都接受一个可选的协同程序参数作为第一个参数，从外部来debug这个协同程序
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7-2" class="outline-4">
<h4 id="sec-3-7-2">钩子</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
可以注册钩子函数，特定时间发生时被调用。
debug.sethook(函数名，事件码字符串，[count计数])
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">call</td>
<td class="left">函数调用时</td>
<td class="left">c</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">return</td>
<td class="left">函数返回时</td>
<td class="left">r</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">line</td>
<td class="left">执行一行新代码时</td>
<td class="left">l</td>
<td class="left">回调函数第二个参数为行号</td>
</tr>

<tr>
<td class="left">count</td>
<td class="left">执行完指定数量的指令后</td>
<td class="left">第三个参数指定计数</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
关闭钩子使用sethook设置为空便可
</p>
</div>
</div>
<div id="outline-container-sec-3-7-3" class="outline-4">
<h4 id="sec-3-7-3">性能剖析器</h4>
<div class="outline-text-4" id="text-3-7-3">
<p>
如果做计时性能剖析，最好使用C接口，Lua 调用钩子的代价太高，对于计数性的剖析，Lua 便可以做的很好。
一个简单的计数剖析器
</p>
<pre class="example">
local Counters = {}
local Names = {}

local function hook() 
  local f = debug.getinfo(2, "f").func
  if Counters[f] = nil then 
    Counters[f] = 1
    Names[f] = debug.getinfo(s "Sn")
  else
    Counters[f] = Counters[f] + 1
  end
end

function getname(func) -- 获取函数的信息
  local n = Names[func]
  if n.what == "C" then
    return n.name
  end
  local lc = string.format("[%s]:%s, n.short_src, n.linedefined")
  if n.namewhat ~= "" then
    return string.format("%s (%s)", lc, n.name)
  else
    return lc
  end
end

local f = assert(loadfile(arg[1]))
debug.sethook(hook, "c")
f()
debug.sethook()

for func, count in pairs(Counters) do
  print(getname(func), count)
end
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Part IV: The C API</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">C API 概述</h3>
<div class="outline-text-3" id="text-4-1">
<p>
C API 是一组能使C代码与Lua交互的函数。其中包括读写Lua全局变量，调用Lua函数， 运行一段Lua代码，
以及注册C函数以供Lua代码调用等。
:TODO
</p>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2014-08-20</span>
        <span title="last modification date" class="post-info">2015-04-24</span>
        <span title="tags" class="post-info"><a href="/tags/学习笔记/">学习笔记</a></span>
        <span title="author" class="post-info">Pengcheng Li</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2014/08/20/lua-笔记";
          var disqus_url = "http://blog.lpch.me/blog/2014/08/20/lua-笔记";
          var disqus_shortname = 'lpch';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-62225597-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:lpc1983 &lt;at&gt; gmail &lt;dot&gt; com">Pengcheng Li</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
